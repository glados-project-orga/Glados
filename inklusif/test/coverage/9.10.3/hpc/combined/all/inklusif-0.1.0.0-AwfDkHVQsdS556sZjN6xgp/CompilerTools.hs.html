<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>module CompilerTools (
<span class="lineno">    2 </span>    appendHeader,
<span class="lineno">    3 </span>    appendDefines,
<span class="lineno">    4 </span>    appendBody,
<span class="lineno">    5 </span>    appendSymbolTable,
<span class="lineno">    6 </span>    storeInConstantPool,
<span class="lineno">    7 </span>    getTypePrefix,
<span class="lineno">    8 </span>    typePrefixVal,
<span class="lineno">    9 </span>    getLitArrayType,
<span class="lineno">   10 </span>    isArrayMixed,
<span class="lineno">   11 </span>    validAssignmentType,
<span class="lineno">   12 </span>    getNuancedArray,
<span class="lineno">   13 </span>    convertToType,
<span class="lineno">   14 </span>    addValToHeader,
<span class="lineno">   15 </span>    getArraySubType,
<span class="lineno">   16 </span>    isArrayGivenType,
<span class="lineno">   17 </span>    isClassDefined,
<span class="lineno">   18 </span>    getEnumValue,
<span class="lineno">   19 </span>    getFromEnum,
<span class="lineno">   20 </span>    )
<span class="lineno">   21 </span>where
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>import Data.Either (lefts, rights)
<span class="lineno">   24 </span>import Data.Maybe (listToMaybe, fromMaybe)
<span class="lineno">   25 </span>import CompilerTypes(
<span class="lineno">   26 </span>    CompilerData,
<span class="lineno">   27 </span>    ConstantPool,
<span class="lineno">   28 </span>    Defines,
<span class="lineno">   29 </span>    Bytecode,
<span class="lineno">   30 </span>    SymbolTable,
<span class="lineno">   31 </span>    TypeEq(..),
<span class="lineno">   32 </span>    TypeNormalized(..),
<span class="lineno">   33 </span>    Convert(..),
<span class="lineno">   34 </span>    SearchTypes(..),
<span class="lineno">   35 </span>    )
<span class="lineno">   36 </span>import SymbolTableUtils (getVarType, getVarType)
<span class="lineno">   37 </span>import FunctionUtils (getFunctionReturnType)
<span class="lineno">   38 </span>import Ast (Declaration(..),
<span class="lineno">   39 </span>    Expr(..),
<span class="lineno">   40 </span>    CallExpr(..),
<span class="lineno">   41 </span>    MethodCallExpr(..),
<span class="lineno">   42 </span>    ClassDecl(..),
<span class="lineno">   43 </span>    StructField(..),
<span class="lineno">   44 </span>    Type(..),
<span class="lineno">   45 </span>    Literal(..),
<span class="lineno">   46 </span>    ArrayVar(..),
<span class="lineno">   47 </span>    EnumField(..),
<span class="lineno">   48 </span>    EnumDecl(..),
<span class="lineno">   49 </span>    UnaryOp(..),
<span class="lineno">   50 </span>    ClassAccess(..),
<span class="lineno">   51 </span>    )
<span class="lineno">   52 </span>import Data.List (find)
<span class="lineno">   53 </span>import Data.Foldable (asum)
<span class="lineno">   54 </span>
<span class="lineno">   55 </span>appendHeader :: CompilerData -&gt; ConstantPool -&gt; CompilerData
<span class="lineno">   56 </span><span class="decl"><span class="istickedoff">appendHeader (header, def, body, symblTable) newHead =</span>
<span class="lineno">   57 </span><span class="spaces">    </span><span class="istickedoff">(header ++ newHead, def, body, symblTable)</span></span>
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>addValToHeader :: CompilerData -&gt; Expr -&gt; Either String CompilerData
<span class="lineno">   60 </span><span class="decl"><span class="nottickedoff">addValToHeader prog (LitExpr (IntLit i)) = Right (appendHeader prog [show i])</span>
<span class="lineno">   61 </span><span class="spaces"></span><span class="nottickedoff">addValToHeader prog (LitExpr (FloatLit f)) = Right (appendHeader prog [show f])</span>
<span class="lineno">   62 </span><span class="spaces"></span><span class="nottickedoff">addValToHeader prog (LitExpr (DoubleLit d)) = Right (appendHeader prog [show d])</span>
<span class="lineno">   63 </span><span class="spaces"></span><span class="nottickedoff">addValToHeader prog (LitExpr (CharLit c)) = Right (appendHeader prog [show c])</span>
<span class="lineno">   64 </span><span class="spaces"></span><span class="nottickedoff">addValToHeader prog (LitExpr (StringLit s)) = Right (appendHeader prog [show s])</span>
<span class="lineno">   65 </span><span class="spaces"></span><span class="nottickedoff">addValToHeader prog (LitExpr (BoolLit b)) = Right (appendHeader prog [show b])</span>
<span class="lineno">   66 </span><span class="spaces"></span><span class="nottickedoff">addValToHeader prog (LitExpr (LongLit l)) = Right (appendHeader prog [show l])</span>
<span class="lineno">   67 </span><span class="spaces"></span><span class="nottickedoff">addValToHeader _ _ = Left &quot;Unsupported literal type for header addition.&quot;</span></span>
<span class="lineno">   68 </span>
<span class="lineno">   69 </span>appendDefine :: Declaration -&gt; Defines -&gt; Defines
<span class="lineno">   70 </span><span class="decl"><span class="istickedoff">appendDefine (Function function) (c, fun, st, en, td, count) = <span class="nottickedoff">(c, fun ++ [function], st, en, td, count)</span></span>
<span class="lineno">   71 </span><span class="spaces"></span><span class="istickedoff">appendDefine (Class struct) (c, fun, st, en, td, count) = <span class="nottickedoff">(c, fun, st ++ [struct], en, td, count)</span></span>
<span class="lineno">   72 </span><span class="spaces"></span><span class="istickedoff">appendDefine (Enum enum) (c, fun, st, en, td, count) = <span class="nottickedoff">(c, fun, st, en ++ [enum], td, count)</span></span>
<span class="lineno">   73 </span><span class="spaces"></span><span class="istickedoff">appendDefine (Typedef typedef) (c, fun, st, en, td, count) = (c, fun, st, en, td ++ [typedef], count)</span></span>
<span class="lineno">   74 </span>
<span class="lineno">   75 </span>appendDefines :: CompilerData -&gt; [Declaration] -&gt; CompilerData
<span class="lineno">   76 </span><span class="decl"><span class="istickedoff">appendDefines prog [] = prog</span>
<span class="lineno">   77 </span><span class="spaces"></span><span class="istickedoff">appendDefines (header, def, body, symblTable) (newDef:decl) = appendDefines new_prog decl</span>
<span class="lineno">   78 </span><span class="spaces">    </span><span class="istickedoff">where new_prog = (header, appendDefine newDef def, body, symblTable)</span></span>
<span class="lineno">   79 </span>
<span class="lineno">   80 </span>appendBody :: CompilerData -&gt; Bytecode -&gt; CompilerData
<span class="lineno">   81 </span><span class="decl"><span class="istickedoff">appendBody (header, def, body, symblTable) newBody =</span>
<span class="lineno">   82 </span><span class="spaces">    </span><span class="istickedoff">(header, def, body ++ newBody, symblTable)</span></span>
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>appendSymbolTable :: CompilerData -&gt; SymbolTable -&gt; CompilerData
<span class="lineno">   85 </span><span class="decl"><span class="istickedoff">appendSymbolTable (header, def, body, symblTable) newSymblTable =</span>
<span class="lineno">   86 </span><span class="spaces">    </span><span class="istickedoff">(header, def, body, symblTable ++ newSymblTable)</span></span>
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>storeInConstantPool :: CompilerData -&gt; String -&gt; (CompilerData, Int)
<span class="lineno">   89 </span><span class="decl"><span class="nottickedoff">storeInConstantPool prog@(header, _, _, _) newElem = (appendHeader prog [newElem], length header)</span></span>
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>getTypePrefix :: String -&gt; String
<span class="lineno">   92 </span><span class="decl"><span class="nottickedoff">getTypePrefix &quot;int&quot; = &quot;i&quot;</span>
<span class="lineno">   93 </span><span class="spaces"></span><span class="nottickedoff">getTypePrefix &quot;float&quot; = &quot;f&quot;</span>
<span class="lineno">   94 </span><span class="spaces"></span><span class="nottickedoff">getTypePrefix &quot;double&quot; = &quot;d&quot;</span>
<span class="lineno">   95 </span><span class="spaces"></span><span class="nottickedoff">getTypePrefix &quot;char&quot; = &quot;c&quot;</span>
<span class="lineno">   96 </span><span class="spaces"></span><span class="nottickedoff">getTypePrefix &quot;bool&quot; = &quot;b&quot;</span>
<span class="lineno">   97 </span><span class="spaces"></span><span class="nottickedoff">getTypePrefix _ = &quot;a&quot;</span></span>
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>typePrefixVal :: Type -&gt; String
<span class="lineno">  100 </span><span class="decl"><span class="nottickedoff">typePrefixVal (IntType ) = &quot;i&quot;</span>
<span class="lineno">  101 </span><span class="spaces"></span><span class="nottickedoff">typePrefixVal (LongType ) = &quot;l&quot;</span>
<span class="lineno">  102 </span><span class="spaces"></span><span class="nottickedoff">typePrefixVal (FloatType ) = &quot;f&quot;</span>
<span class="lineno">  103 </span><span class="spaces"></span><span class="nottickedoff">typePrefixVal (DoubleType ) = &quot;d&quot;</span>
<span class="lineno">  104 </span><span class="spaces"></span><span class="nottickedoff">typePrefixVal (CharType ) = &quot;c&quot;</span>
<span class="lineno">  105 </span><span class="spaces"></span><span class="nottickedoff">typePrefixVal (BoolType ) = &quot;i&quot;</span>
<span class="lineno">  106 </span><span class="spaces"></span><span class="nottickedoff">typePrefixVal (ArrayType _) = &quot;a&quot;</span>
<span class="lineno">  107 </span><span class="spaces"></span><span class="nottickedoff">typePrefixVal _ = &quot;a&quot;</span></span>
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>getNuancedArray :: [Expr] -&gt; CompilerData -&gt; ([String], [Type])
<span class="lineno">  110 </span><span class="decl"><span class="nottickedoff">getNuancedArray [] _ = ([], [])</span>
<span class="lineno">  111 </span><span class="spaces"></span><span class="nottickedoff">getNuancedArray exprs prog = (lefts arrayTypes, rights arrayTypes)</span>
<span class="lineno">  112 </span><span class="spaces">    </span><span class="nottickedoff">where arrayTypes = map (\expr -&gt; convertToType expr prog) exprs</span></span>
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>isArrayGivenType :: Type -&gt; [Type] -&gt; Bool
<span class="lineno">  115 </span><span class="decl"><span class="nottickedoff">isArrayGivenType VoidType [] = True</span>
<span class="lineno">  116 </span><span class="spaces"></span><span class="nottickedoff">isArrayGivenType t xs = all (== t) xs</span></span>
<span class="lineno">  117 </span>
<span class="lineno">  118 </span>isArrayMixed :: [Type] -&gt; Bool
<span class="lineno">  119 </span><span class="decl"><span class="nottickedoff">isArrayMixed [] = False</span>
<span class="lineno">  120 </span><span class="spaces"></span><span class="nottickedoff">isArrayMixed (headType:xs) = any (/= headType) xs</span></span>
<span class="lineno">  121 </span>
<span class="lineno">  122 </span>getLitArrayType :: [Expr] -&gt; CompilerData -&gt; Either String Type
<span class="lineno">  123 </span><span class="decl"><span class="nottickedoff">getLitArrayType [] _ = Right (ArrayType (ArrayVar VoidType (LitExpr (IntLit 0))))</span>
<span class="lineno">  124 </span><span class="spaces"></span><span class="nottickedoff">getLitArrayType exprs prog | not (null arrayError) = Left firstError</span>
<span class="lineno">  125 </span><span class="spaces">                           </span><span class="nottickedoff">| isArrayMixed validTypes = Left &quot;Array contains mixed expression types.&quot;</span>
<span class="lineno">  126 </span><span class="spaces">                           </span><span class="nottickedoff">| otherwise = Right (ArrayType (ArrayVar (fval) (LitExpr (IntLit 0))))</span>
<span class="lineno">  127 </span><span class="spaces">    </span><span class="nottickedoff">where firstError = fromMaybe &quot;Unknown error&quot; (listToMaybe arrayError)</span>
<span class="lineno">  128 </span><span class="spaces">          </span><span class="nottickedoff">fval = fromMaybe VoidType (listToMaybe validTypes)</span>
<span class="lineno">  129 </span><span class="spaces">          </span><span class="nottickedoff">(arrayError, validTypes) = getNuancedArray exprs prog</span></span>
<span class="lineno">  130 </span>
<span class="lineno">  131 </span>getClasses :: CompilerData -&gt; [ClassDecl]
<span class="lineno">  132 </span><span class="decl"><span class="nottickedoff">getClasses (_, (_, _, classes, _, _, _), _, _) = classes</span></span>
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>getClass :: String -&gt; CompilerData -&gt; Either String ClassDecl
<span class="lineno">  135 </span><span class="decl"><span class="nottickedoff">getClass clname prog = </span>
<span class="lineno">  136 </span><span class="spaces">    </span><span class="nottickedoff">maybe (Left (&quot;Class &quot; ++ clname ++ &quot; does not exist.&quot;))</span>
<span class="lineno">  137 </span><span class="spaces">          </span><span class="nottickedoff">Right (find (\(ClassDecl _ name _ _) -&gt; name == clname) classes)</span>
<span class="lineno">  138 </span><span class="spaces">    </span><span class="nottickedoff">where classes = getClasses prog</span></span>
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>getClassVarType ::  String -&gt; String -&gt; CompilerData -&gt; Either String Type
<span class="lineno">  141 </span><span class="decl"><span class="nottickedoff">getClassVarType cTypeName varName prog =</span>
<span class="lineno">  142 </span><span class="spaces">    </span><span class="nottickedoff">getClass cTypeName prog &gt;&gt;= \(ClassDecl _ _ fields _) -&gt;</span>
<span class="lineno">  143 </span><span class="spaces">            </span><span class="nottickedoff">maybe (Left (&quot;Variable &quot; ++ varName ++ &quot; does not exist in class &quot; ++ cTypeName ++ &quot;.&quot;))</span>
<span class="lineno">  144 </span><span class="spaces">            </span><span class="nottickedoff">(Right . structFieldType) (find (\(StructField name _) -&gt; name == varName) fields)</span></span>
<span class="lineno">  145 </span>
<span class="lineno">  146 </span>isClassDefined :: String -&gt; Defines -&gt; Bool
<span class="lineno">  147 </span><span class="decl"><span class="nottickedoff">isClassDefined searched (_, _, classDefs, _, _, _) =</span>
<span class="lineno">  148 </span><span class="spaces">    </span><span class="nottickedoff">any (\(ClassDecl _ name _ _) -&gt; name == searched) classDefs</span></span>
<span class="lineno">  149 </span>
<span class="lineno">  150 </span>normalizeBinOp :: (Expr, Expr) -&gt; CompilerData -&gt; Either String TypeNormalized
<span class="lineno">  151 </span><span class="decl"><span class="nottickedoff">normalizeBinOp (left, right) prog =</span>
<span class="lineno">  152 </span><span class="spaces">    </span><span class="nottickedoff">convertToType left prog &gt;&gt;= \normLeft -&gt;</span>
<span class="lineno">  153 </span><span class="spaces">    </span><span class="nottickedoff">convertToType right prog &gt;&gt;= \normRight -&gt;</span>
<span class="lineno">  154 </span><span class="spaces">    </span><span class="nottickedoff">Right (opPriorityTable (normLeft, normRight))</span></span>
<span class="lineno">  155 </span>
<span class="lineno">  156 </span>opPriorityTable :: (Type, Type) -&gt; TypeNormalized
<span class="lineno">  157 </span><span class="decl"><span class="nottickedoff">opPriorityTable op | any (== DoubleType) op = (TypeNorm DoubleType)</span>
<span class="lineno">  158 </span><span class="spaces">                   </span><span class="nottickedoff">| any (== FloatType) op = (TypeNorm FloatType)</span>
<span class="lineno">  159 </span><span class="spaces">                   </span><span class="nottickedoff">| any (== LongType) op = (TypeNorm LongType)</span>
<span class="lineno">  160 </span><span class="spaces">                   </span><span class="nottickedoff">| any (== IntType) op = (TypeNorm IntType)</span>
<span class="lineno">  161 </span><span class="spaces">                   </span><span class="nottickedoff">| any (== BoolType) op = (TypeNorm BoolType)</span>
<span class="lineno">  162 </span><span class="spaces">                   </span><span class="nottickedoff">| otherwise = (TypeNorm VoidType)</span></span>
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>getFromEnum :: [EnumField] -&gt; String -&gt; Maybe Int
<span class="lineno">  165 </span><span class="decl"><span class="nottickedoff">getFromEnum enumfields searched =</span>
<span class="lineno">  166 </span><span class="spaces">    </span><span class="nottickedoff">find (\enumfield -&gt; declName enumfield == searched) enumfields &gt;&gt;= declValue</span></span>
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>getEnumValue :: [EnumDecl] -&gt; String -&gt; Maybe Int
<span class="lineno">  169 </span><span class="decl"><span class="nottickedoff">getEnumValue enums searched =</span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="nottickedoff">asum $ map (\enum -&gt; getFromEnum (enumDecl enum) searched) enums</span></span>
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>getArraySubType :: Type -&gt; Either String Type
<span class="lineno">  173 </span><span class="decl"><span class="nottickedoff">getArraySubType (ArrayType (ArrayVar t _)) = Right t</span>
<span class="lineno">  174 </span><span class="spaces"></span><span class="nottickedoff">getArraySubType _ = Left &quot;Type is not an array type when searching array type.&quot;</span></span>
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>normalizeClassVarType :: String -&gt; ClassAccess -&gt; CompilerData -&gt; Either String TypeNormalized
<span class="lineno">  177 </span><span class="decl"><span class="nottickedoff">normalizeClassVarType clDecName (ClassVarAccess varName) prog =</span>
<span class="lineno">  178 </span><span class="spaces">    </span><span class="nottickedoff">getClassVarType clDecName varName prog &gt;&gt;= \typ -&gt; Right (TypeNorm typ)</span>
<span class="lineno">  179 </span><span class="spaces"></span><span class="nottickedoff">normalizeClassVarType clDecName (ClassArrayAccess varName _) prog =</span>
<span class="lineno">  180 </span><span class="spaces">    </span><span class="nottickedoff">getClassVarType clDecName varName prog &gt;&gt;= getArraySubType &gt;&gt;= \typ -&gt; Right (TypeNorm typ)</span>
<span class="lineno">  181 </span><span class="spaces"></span><span class="nottickedoff">normalizeClassVarType clDecName (ClassMethodCall (CallExpr methName _)) prog =</span>
<span class="lineno">  182 </span><span class="spaces">    </span><span class="nottickedoff">case getFunctionReturnType methName prog of</span>
<span class="lineno">  183 </span><span class="spaces">        </span><span class="nottickedoff">Just retType -&gt; Right (TypeNorm retType)</span>
<span class="lineno">  184 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt; Left (&quot;Unknown method return type for method &quot; ++ methName ++ &quot; in class &quot; ++ clDecName)</span>
<span class="lineno">  185 </span><span class="spaces"></span><span class="nottickedoff">normalizeClassVarType clDecName (ClassClassAccess nclName cacc) prog = normalizeClassVarType nDname cacc prog</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="nottickedoff">where nDname = case getClassVarType clDecName nclName prog of</span>
<span class="lineno">  187 </span><span class="spaces">            </span><span class="nottickedoff">Right (CustomType name) -&gt; name</span>
<span class="lineno">  188 </span><span class="spaces">            </span><span class="nottickedoff">_ -&gt; &quot;&quot;</span></span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>normalizeExprType :: Expr -&gt; CompilerData -&gt; Either String TypeNormalized
<span class="lineno">  191 </span><span class="decl"><span class="istickedoff">normalizeExprType (LitExpr lit) _ = Right (LitNorm lit)</span>
<span class="lineno">  192 </span><span class="spaces"></span><span class="istickedoff">normalizeExprType (VarExpr name) prog@(_, (_, _, _, enums, _, _), _, _) =</span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">case getEnumValue enums name of</span></span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Just _ -&gt; Right (TypeNorm IntType)</span></span>
<span class="lineno">  195 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; getVarType name prog &gt;&gt;= (Right . TypeNorm)</span></span>
<span class="lineno">  196 </span><span class="spaces"></span><span class="istickedoff">normalizeExprType (ArrayVarExpr name _) prog = <span class="nottickedoff">getVarType name prog</span></span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">&gt;&gt;= getArraySubType &gt;&gt;= (Right . TypeNorm)</span></span>
<span class="lineno">  198 </span><span class="spaces"></span><span class="istickedoff">normalizeExprType (BinOpExpr _ l r) prog = <span class="nottickedoff">normalizeBinOp (l, r) prog</span></span>
<span class="lineno">  199 </span><span class="spaces"></span><span class="istickedoff">normalizeExprType (CastExpr t _) _ = <span class="nottickedoff">Right (TypeNorm t)</span></span>
<span class="lineno">  200 </span><span class="spaces"></span><span class="istickedoff">normalizeExprType (ClassVarExpr clName classAccess) prog =</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">dName &gt;&gt;= \dname -&gt; normalizeClassVarType dname classAccess prog</span></span>
<span class="lineno">  202 </span><span class="spaces">    </span><span class="istickedoff">where <span class="nottickedoff">dName = case getVarType clName prog of</span></span>
<span class="lineno">  203 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">Right (CustomType name) -&gt; Right name</span></span>
<span class="lineno">  204 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; Left (&quot;Class type of &quot; ++ clName ++ &quot; does not exist.&quot;)</span></span>
<span class="lineno">  205 </span><span class="spaces"></span><span class="istickedoff">normalizeExprType (ClassConstructorExpr clName _) (_, defs, _, _)</span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">isClassDefined clName defs</span> = <span class="nottickedoff">Right (TypeNorm (CustomType clName))</span></span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">Left (&quot;Class &quot; ++ clName ++ &quot; does not exist.&quot;)</span></span>
<span class="lineno">  208 </span><span class="spaces"></span><span class="istickedoff">normalizeExprType (ArrayLiteral arr) prog =</span>
<span class="lineno">  209 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">getLitArrayType arr prog &gt;&gt;= \typ -&gt; Right (TypeNorm typ)</span></span>
<span class="lineno">  210 </span><span class="spaces"></span><span class="istickedoff">normalizeExprType (CallExpression (CallExpr name _)) prog =</span>
<span class="lineno">  211 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">case getFunctionReturnType name prog of</span></span>
<span class="lineno">  212 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Just retType -&gt; Right (TypeNorm retType)</span></span>
<span class="lineno">  213 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; Left &quot;Unknown function return type&quot;</span></span>
<span class="lineno">  214 </span><span class="spaces"></span><span class="istickedoff">normalizeExprType (MethodCallExpression (MethodCallExpr _ name _)) prog =</span>
<span class="lineno">  215 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">case getFunctionReturnType name prog of</span></span>
<span class="lineno">  216 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Just retType -&gt; Right (TypeNorm retType)</span></span>
<span class="lineno">  217 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; Left &quot;Unknown function return type&quot;</span></span>
<span class="lineno">  218 </span><span class="spaces"></span><span class="istickedoff">normalizeExprType (UnaryOpExpr op expr) prog = <span class="nottickedoff">normalizeUnaryOp op expr prog</span></span>
<span class="lineno">  219 </span><span class="spaces"></span><span class="istickedoff">normalizeExprType expr _ = <span class="nottickedoff">Left (&quot;Unknown expression type :&quot; ++ (show expr))</span></span></span>
<span class="lineno">  220 </span>
<span class="lineno">  221 </span>normalizeUnaryOp :: UnaryOp -&gt; Expr -&gt; CompilerData -&gt; Either String TypeNormalized
<span class="lineno">  222 </span><span class="decl"><span class="nottickedoff">normalizeUnaryOp Not _ _ = Right (TypeNorm BoolType)</span>
<span class="lineno">  223 </span><span class="spaces"></span><span class="nottickedoff">normalizeUnaryOp _ expr prog = normalizeExprType expr prog</span></span>
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>normalizeToType :: TypeNormalized -&gt; Type
<span class="lineno">  226 </span><span class="decl"><span class="istickedoff">normalizeToType (TypeNorm typ) = <span class="nottickedoff">typ</span></span>
<span class="lineno">  227 </span><span class="spaces"></span><span class="istickedoff">normalizeToType (LitNorm lit) = convert lit</span></span>
<span class="lineno">  228 </span>
<span class="lineno">  229 </span>convertToType :: Expr -&gt; CompilerData-&gt; Either String Type
<span class="lineno">  230 </span><span class="decl"><span class="istickedoff">convertToType expr prog = normalizeExprType expr <span class="nottickedoff">prog</span> &gt;&gt;= (Right . normalizeToType)</span></span>
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>validAssignmentType :: SearchTypes -&gt; SearchTypes -&gt; CompilerData -&gt; Bool
<span class="lineno">  233 </span><span class="decl"><span class="istickedoff">validAssignmentType (SearchType t1) (SearchType t2) _ = t1 `typeEq` t2</span>
<span class="lineno">  234 </span><span class="spaces"></span><span class="istickedoff">validAssignmentType (SearchExpr expr) (SearchType t) prog = t `typeEq` (convertToType expr <span class="nottickedoff">prog</span>)</span>
<span class="lineno">  235 </span><span class="spaces"></span><span class="istickedoff">validAssignmentType (SearchType t) (SearchExpr expr) prog = <span class="nottickedoff">t `typeEq` (convertToType expr prog)</span></span>
<span class="lineno">  236 </span><span class="spaces"></span><span class="istickedoff">validAssignmentType (SearchExpr expr1) (SearchExpr expr2) prog = <span class="nottickedoff">normed1 `typeEq` normed2</span></span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="istickedoff">where <span class="nottickedoff">normed1 = convertToType expr1 prog</span></span>
<span class="lineno">  238 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">normed2 = convertToType expr2 prog</span></span></span>

</pre>
</body>
</html>
