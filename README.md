# GLaDOS — Generic Language And Data Operand Syntax

GLaDOS is a multi-part programming language project developed in Haskell as part
of the three modules a third-year student can pick at EPITECH.  
The project progressively evolves from a minimalist Lisp interpreter to a full
compiler targeting a custom virtual machine.

The project is divided into several mandatory parts, each building on the
previous one, with a strong focus on testing, compilation and
documentation.



<img width="403" height="370" alt="image" src="https://github.com/user-attachments/assets/757d0797-a7b5-4fa3-a049-1783733a586a" />



## Project structure

The repository is organized into the following main directories:

### `lisp/`
This directory contains **Part 1** of the project.

It implements a minimalist Lisp interpreter inspired by Chez Scheme, including:
- Parsing of S-expressions
- Evaluation of expressions
- Variable bindings
- User-defined functions and lambdas
- Conditional expressions
- Built-in arithmetic and comparison operators

This part serves as an introduction to language implementation and provides
foundations reused in later stages.


### `inklusif/`
This directory contains the **main compiler**, built as the executable
named **`glados`**.

It implements:
- A custom syntax and grammar (not based on S-expressions)
- Parsing and AST construction
- Semantic and type checks
- Compilation from AST to a JVM-like bytecode

The generated bytecode is intended to be executed by the `glados-vm`
virtual machine, whose instruction set is **inspired by the JVM execution model**
(stack-based evaluation, explicit control flow instructions).


### `vm/`
This directory contains the **Virtual Machine**.

It is built as a separate binary named **`glados-vm`**.

The VM is responsible for:
- Loading and executing bytecode produced by the compiler
- Managing the operand stack
- Handling arithmetic, control flow and return instructions
- Running compiled programs in an isolated runtime

The instruction set represents functions as flat sequences of instructions,
as required by the project specifications.


## Compilation pipeline

The global compilation pipeline is the following:

1. Parsing source code into an Abstract Syntax Tree (AST)
2. Semantic validation and type checking
3. Compilation of expressions and statements into bytecode
4. Execution of the bytecode on the virtual machine

The compiler can also output a human-readable representation of the generated
bytecode for debugging purposes.

## Testing strategy

Testing is a mandatory part of the project (Part 0).

The project includes:
- **Unit tests** to validate individual components
- **Functional tests** to ensure correct behavior of the full pipeline
- Runtime tests using example programs

Tests are designed to prevent regressions and validate language correctness
across all stages of the project.


## CI / CD

A CI/CD pipeline is set up to automate verification of the project.

The pipeline performs:
- Project build from a fresh clone
- Execution of unit and integration tests
- Validation of runtime examples
- Generation of a functional executable

This ensures that each push preserves correctness and that the project can
always be built and executed automatically.


## Build and execution

The project produces two executables:

- **`glados`**: the compiler, located in the `inklusif/` part of the project
- **`glados-vm`**: the virtual machine, located in the `vm/` directory

The compiler translates source programs into bytecode, which is then
executed by the virtual machine.

The project is built using a `Makefile` as required by the specifications.

Typical commands:
- `make` — build both binaries
- `make clean` — remove temporary files
- `make fclean` — clean build artifacts

## Contributors

This project was developed collaboratively as part of the EPITECH curriculum.

The contributors to this project are:

- celianrag
- Pliya
- Luigianiki
- HajarAhazzam
- KerwanC

All contributors participated in the design, implementation and testing
of the project throughout its different stages, working collaboratively
and supporting each other as the project evolved.


